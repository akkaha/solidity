pragma solidity ^0.4.21;

contract Coin {

    // declare a state variable of type address that is publicly accessible.
    // the `address` type is a 160-bit value that does not allow any arithmetic operations.
    // the keyword `public` automatically generates a function that allows you to access the current
    // value of the state variable from outside of the contact. Without this keyword, other contracts
    // have no way to access the variable. The code of the function generated by the compiler is roughly
    // equivalent to the following: `function minter() return (address) { return minter; }`
    address public minter;

    // This line below also craetes a public state variable, but it is a more complex datatype.
    // The type maps address to unsigned integers. Mappings can be seen as hash tables
    // which are virtually initialized such that every possible key exists and is mapped to a
    // value whose byte-representation is all zeros. This analogy does not go too far, though,
    // as it is neither possible to obtain a list of all keys of a mapping, nor a list of all values.
    // So either keep in mind(or better, keep a list or use a more adbanced data type) what you added
    // to the mapping or use it in a context where this is not needed, like this one. The `getter function`
    // created by the `public` keyword is a bit more complex in this case. It roughly looks like the following:
    // ```
    // function balances(address _account) public view returns (uint) {
    //   return balances[_account];
    // }
    // ```
    mapping (address => uint) public balances;

    // The lien declares a so-called `event` which is emitted in the last line of the function `send`.
    // User interfaces(as well as server applications of course) can listen for those events being emitted
    // on the blockchain without much cost. As soon as it is emmited, ths listener will also receive the arguments
    // `from`, `to` and `amount`, which makes it easy to track transactions. In order to listen for this event,
    // you would use 
    // ```
    // Coin.Sent().watch({}, '', function(error, result) {
    //   if (!error) {
    //     console.log("Coin transfer: " + result.args.amount + " coins were sent from " + result.args.from + " to " + result.args.to + ".");
    //     console.log("Balances now:\n" + "Sender: " + Coin.balances.call(result.args.from) + "Receiver: " + Coin.balances.call(result.args.to));
    //   }
    // })
    // ```
    // Note how the automatically generated function `balances` is called from the user interface.
    event Sent(address from, address to, uint amount);

    // The constructor is run during creation of the contract and cannot be called afterwards. It permanently stores 
    // the person creating the contract: `msg`(together with `tx` and `block`) is a magic global variable that contains
    // some properties which allow access to the blockchain. `msg.seder` is always the address where the current(external)
    // function call came from.
    constructor() public {
        minter = msg.sender;
    }

    function mint(address receiver, uint amount) public {
        if (msg.sender != minter) return;
        balances[receiver] += amount;
    }

    function send(address receiver, uint amount) public {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Sent(msg.sender, receiver, amount);
    }
}